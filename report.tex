\documentclass[a4paper,11pt,twoside]{article}
%\documentclass[a4paper,11pt,twoside,se]{article}

\usepackage{UmUStudentReport}
\usepackage{verbatim}   % Multi-line comments using \begin{comment}
\usepackage{courier}    % Nicer fonts are used. (not necessary)
\usepackage{pslatex}    % Also nicer fonts. (not necessary)
\usepackage[pdftex]{graphicx}   % allows including pdf figures
\usepackage{listings}
\usepackage{pgf-umlcd}
\usepackage{blindtext}
\usepackage{rotating}
\usepackage{enumitem}
%\usepackage{lmodern}   % Optional fonts. (not necessary)
%\usepackage{tabularx}
%\usepackage{microtype} % Provides some typographic improvements over default settings
%\usepackage{placeins}  % For aligning images with \FloatBarrier
%\usepackage{booktabs}  % For nice-looking tables
%\usepackage{titlesec}  % More granular control of sections.

% DOCUMENT INFO
% =============
\department{Department of Computing Science}
\coursename{Operating Systems 7.5 p}
\coursecode{5DV171}
\title{Assignment 1}
\author{Niklas Königsson ({\tt{dv15XXX@cs.umu.se}}) \\
Niclas Nyström ({\tt{xxxxxxx@cs.umu.se}}) \\
Lorenz Gerber ({\tt{dv15lgr@cs.umu.se}})
}
\author{Lorenz Gerber ({\tt{dv15lgr@cs.umu.se}} {\tt{lozger03@student.umu.se}})}
\date{2017-09-26}
%\revisiondate{2016-01-18}
\instructor{Jan Erik Moström / Adam Dahlgren Lindström}


% DOCUMENT SETTINGS
% =================
\bibliographystyle{plain}
%\bibliographystyle{ieee}
\pagestyle{fancy}
\raggedbottom
\setcounter{secnumdepth}{2}
\setcounter{tocdepth}{2}
%\graphicspath{{images/}}   %Path for images

\usepackage{float}
\floatstyle{ruled}
\newfloat{listing}{thp}{lop}
\floatname{listing}{Listing}



% DEFINES
% =======
%\newcommand{\mycommand}{<latex code>}

% DOCUMENT
% ========
\begin{document}
\lstset{language=C}
\maketitle
\thispagestyle{empty}
%\newpage
%\tableofcontents
%\thispagestyle{empty}
\newpage

\clearpage
\pagenumbering{arabic}

\section{Introduction}
This assignment was about implementing a new system call in the linux kernel. The
system call should gather information about number of processes, observed file
descriptors and pending signals for the current user. The information shall be obtained
in kernel space and then sent back to user space.

\section{Setup and Preparation}
A recent version of raspbian was installed on the SD card. Here we used `Raspian
Stretch Lite', Version September 2017, release 2017-09-07 with initial Kernel version
4.9. For performance and convenience, we cross-compile the kernel from a Linux machine. Hence
the toolchain had to be set up for cross compilation. The toolchain was obtained
from \verb+git clone https://github.com/raspberrypi/tools+. The Linux kernal source
repository for Raspberry Pi Raspian was forked form
\verb+https://github.com/raspberrypi/linux+. For convenience, scripts for clean up,
configuration, build and deployment were setup
(\verb+https://github.com/lorenzgerber/kernel_build_scripts.git+).

\section{Implementation Syscall}
\subsection{Summary of Implementation}
All data needed to implement the required syscall is available in the \verb+struct task_struct+
that is defined in the \verb+sched.h+ file. We did a step wise implementation where
we first wrote a simple `Helloworld' syscall that would print to the kernel message
buffer. In a second iteration, we implemented the data gathering which will be
described in more detail below. Finally, we coded the data transfer between user and
kernel space. During all steps, we tried to use test and verification procedures
to make sure that the obtained data is corect.

\subsection{Used Datastructures}
To get an idea of the involved data structures, initially chapter 3 of \cite{bovetcesati2005}
was consulted and compared with the datastructures found in the code. Using Eclipse
as IDE proved to be of great use for getting pop-up descriptions of macros and
functions. Further, it greatly simplified navigating the code by the possiblity
to link from implementations to definitions etc.

As mentioned earlier, the main data container to be used was the \verb+stuct task_struct+
that was obtained as a double linked list and coulb be traversed to calculate
the number of processes with the current uid.

Within the iteration loop, the number of watched file descriptors was also obtained
from the \verb+files+ struct that contained another struct \verb+fdtab+ with the
field `open'.

The pending signals were extracted by bitshifting from the personal and shared
pending signal data structures (\verb+signal->shared_pending.signal.sig+,
\verb+pending.signal.sig+). A good description of the signal data structures
was found in \cite{love2010}.


\subsection{Files changed and added}
Below follows a list of files that were modified.
\begin{enumerate}
  \item \textit{kernel/Makefile}, the new source file was included
  \item \textit{include/uapi/asm-generic/unistd.h}, a define in the arch generic unistd header
  \item \textit{arch/arm/include/uapi/unistd.h}, a define in the arch specific unistd header
  \item \textit{arch/arm/kernel/calls.S}, the call was added in arch specific the syscall table
  \item \textit{include/linux/syscalls.h}, a prototype was added in the syscalls header file
  \item \textit{init/Kconfig}, a reference to the configuration file was added
\end{enumerate}

The new files added were:
\begin{enumerate}
  \item \textit{kernel/Kconfig.processInfo}, the configuration file
  \item \textit{kernel/processInfo.c}, the source file
  \item \textit{include/linux/processInfo.h}, the headers
\end{enumerate}
\subsection{Syscall Return values and error codes}
All return values were verified with separate methods. Number of processes was
compared to using \verb+ps -u uid+. Starting and shutting down processes was
tested to check that the syscall's return value represented the changes. For
open file descriptors were verified using \verb+lsof -u uid | wc -l+. Also here
it was checked during run-time that opening/closing files was represented in the
result values.
Finally, for verifying the pending signals, two small c programs were writte,
where one was only looping over a sleep(5) instruction for a number of times. The
other program was a wrapper that would start a program with blocked \verb+SIGINT+
 signal handler. Invoking the looper with the wrapper, then pressing Ctrl-x
 resulted in pending signals, which was first checked from the console using
 \verb+cat /proc/pid/status+. Then the corresponding procedure was run while invoking
 the syscall to verify the correct values.

\subsection{User space code example}




\addcontentsline{toc}{section}{\refname}
\bibliography{references}

\end{document}
